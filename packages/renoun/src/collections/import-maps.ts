import type { Project } from 'ts-morph'
import tsMorph from 'ts-morph'
import { existsSync, mkdirSync, writeFileSync, readFileSync } from 'node:fs'
import { extname, resolve, join, dirname, relative } from 'node:path'
import globParent from 'glob-parent'
import fastGlob from 'fast-glob'

import { getProject } from '../project/get-project.js'
import { getClosestPackageJsonOrThrow } from '../utils/get-closest-package-json.js'
import { resolveTsConfigPath } from '../utils/resolve-ts-config-path.js'
import {
  WORKSPACE_IS_MODULE,
  PACKAGE_DIRECTORY,
  PACKAGE_IMPORT_PATTERN,
  PACKAGE_FILE_PATTERN,
  COLLECTIONS_IMPORT_NAME,
  COLLECTIONS_FILE_PATH,
} from './constants.js'
import { getCollectionConfigurations } from './get-collection-configurations.js'
import { rewriteCollectionImports } from './rewrite-collection-imports.js'

const packageJsonMeta = getClosestPackageJsonOrThrow()

type GetImport<Exports extends unknown = unknown> = (
  slug: string
) => Promise<Exports>

let importMap = new Map<string, GetImport>()

/**
 * Sets the import maps for a collection's file patterns.
 *
 * @internal
 * @param entries - An array of tuples where the first element is a file pattern and the second element is a function that returns a promise resolving to the import.
 */
export function setImportMap(...entries: (string | GetImport)[]) {
  const parsedEntries: [string, GetImport][] = []

  for (let index = 0; index < entries.length; index += 2) {
    parsedEntries.push([
      entries[index] as string,
      entries[index + 1] as GetImport,
    ])
  }

  importMap = new Map(parsedEntries)
}

/**
 * Retreives the import map for a collection's file pattern.
 *
 * @internal
 * @param slug - The file pattern to retrieve the import map for.
 * @returns The import map for the file pattern.
 */
export function getImportMap<AllExports>(slug: string) {
  return importMap.get(slug) as GetImport<AllExports>
}

/**
 * Generates import maps for each file pattern at the root of the project.
 *
 * @param patterns - An array of file patterns to match.
 * @param sourceFilesMap - A map of file patterns to their respective source files.
 */
async function writeImportMap(
  collectionConfigurations: ReturnType<typeof getCollectionConfigurations>
) {
  const configs = Array.from(collectionConfigurations)
  const importMapEntries: string[] = []

  await Promise.all(
    configs.map(async ([filePattern, options]) => {
      const project = await getProject({
        tsConfigFilePath: options?.tsConfigFilePath || 'tsconfig.json',
      })
      const compilerOptions = project.getCompilerOptions()
      const tsConfigFilePath = compilerOptions.configFilePath
      const tsConfigDirectory = tsConfigFilePath
        ? dirname(String(tsConfigFilePath))
        : project.getDirectoryOrThrow('.').getPath()
      const absoluteGlobPattern =
        compilerOptions.baseUrl && compilerOptions.paths
          ? resolveTsConfigPath(
              tsConfigDirectory,
              compilerOptions.baseUrl,
              compilerOptions.paths,
              filePattern
            )
          : resolve(tsConfigDirectory, filePattern)
      const filePaths = await fastGlob.glob(absoluteGlobPattern)

      if (process.env.NODE_ENV === 'production' && filePaths.length === 0) {
        throw new Error(
          `[renoun] No source files found for collection while attempting to generate import map for file pattern: ${filePattern}
  
  You can fix this error by ensuring the following:
    
    - The file pattern is formatted correctly and targeting files that exist.
    - If using a relative path, ensure the "tsConfigFilePath" option is targeting the correct workspace.
    - If you continue to see this error, please file an issue: https://github.com/souporserious/renoun/issues\n`
        )
      }

      const relativeGlobPattern = relative(
        join(process.cwd(), PACKAGE_DIRECTORY),
        absoluteGlobPattern
      )
      const baseGlobPattern = globParent(relativeGlobPattern)
      const allExtensions = Array.from(new Set(filePaths.map(extname)))

      allExtensions.forEach((extension) => {
        const trimmedExtension = extension.slice(1)

        importMapEntries.push(
          `\`${trimmedExtension}:${filePattern}\``,
          `(slug) => import(\`${baseGlobPattern}/\${slug}${extension}\`)`
        )
      })
    })
  )

  const currentImportMap = existsSync(COLLECTIONS_FILE_PATH)
    ? readFileSync(COLLECTIONS_FILE_PATH, 'utf-8')
    : null
  const nextImportMap = [
    `/*\n * This file is automatically generated and managed by the \`renoun\` package.\n * It is aliased in the tsconfig.json file and can be added to .gitignore or committed. \n */`,
    `import { createCollection } from '${COLLECTIONS_IMPORT_NAME}'\n`,
    `createCollection.setImportMap(\n${importMapEntries
      .flatMap((entry) => `  ${entry}`)
      .join(',\n')}\n)\n`,
    `export * from '${COLLECTIONS_IMPORT_NAME}'\n`,
  ].join('\n')

  if (currentImportMap === nextImportMap) {
    return
  }

  writeFileSync(COLLECTIONS_FILE_PATH, nextImportMap)
}

/** Updates the tsconfig.json file to include the `renoun` package alias in the `paths` field. */
function codemodTsConfigPaths(project: Project) {
  const tsconfigFilePath = project.getCompilerOptions().configFilePath

  if (typeof tsconfigFilePath === 'string') {
    const tsconfigContents = readFileSync(tsconfigFilePath, 'utf-8') || '{}'
    const tsconfigJson = JSON.parse(tsconfigContents)

    if (!tsconfigJson.compilerOptions) {
      tsconfigJson.compilerOptions = {}
    }

    if (!tsconfigJson.compilerOptions.baseUrl) {
      tsconfigJson.compilerOptions.baseUrl = '.'
    }

    if (!tsconfigJson.compilerOptions.paths) {
      tsconfigJson.compilerOptions.paths = {}
    }

    if (!tsconfigJson.compilerOptions.paths[PACKAGE_IMPORT_PATTERN]) {
      tsconfigJson.compilerOptions.paths[PACKAGE_IMPORT_PATTERN] = [
        PACKAGE_FILE_PATTERN,
      ]

      writeFileSync(tsconfigFilePath, JSON.stringify(tsconfigJson, null, 2))
    }
  }
}

/** Adds or updates the imports field in package.json to include the custom import alias. */
function codemodPackageJson() {
  if (packageJsonMeta.packageJson.imports) {
    if (packageJsonMeta.packageJson.imports[PACKAGE_IMPORT_PATTERN]) {
      return
    }

    Object.assign(packageJsonMeta.packageJson.imports, {
      [PACKAGE_IMPORT_PATTERN]: PACKAGE_FILE_PATTERN,
    })

    writeFileSync(
      packageJsonMeta.path,
      JSON.stringify(packageJsonMeta.packageJson, null, 2)
    )
  } else {
    const newPackageJson: Record<string, any> = {}

    // insert imports after "type: module"
    for (const key in packageJsonMeta.packageJson) {
      newPackageJson[key] = packageJsonMeta.packageJson[key]
      if (key === 'type') {
        newPackageJson.imports = {
          [PACKAGE_IMPORT_PATTERN]: PACKAGE_FILE_PATTERN,
        }
      }
    }

    writeFileSync(packageJsonMeta.path, JSON.stringify(newPackageJson, null, 2))
  }
}

let project: Project

/** Initializes an import map at the root of the project based on all `createCollection` configurations. */
export async function generateCollectionImportMap(filename?: string) {
  /* Use a default project to find all collection configurations and generate the collection import map. */
  if (!project) {
    project = new tsMorph.Project({ tsConfigFilePath: 'tsconfig.json' })
  }

  /* Refresh source file if the contents changed. */
  if (filename) {
    const sourceFile = project.getSourceFile(filename)

    if (sourceFile) {
      await sourceFile.refreshFromFileSystem()
    }
  }

  /* Prime the file so it gets picked up by the bundler. */
  if (!existsSync(PACKAGE_DIRECTORY)) {
    mkdirSync(PACKAGE_DIRECTORY)
  }

  writeFileSync(
    COLLECTIONS_FILE_PATH,
    `export * from '${COLLECTIONS_IMPORT_NAME}';\n`
  )

  /* Update the tsconfig.json file to include the `renoun` package alias in the `paths` field. */
  codemodTsConfigPaths(project)

  /* Update the imports field in package.json to include the custom import alias. */
  if (WORKSPACE_IS_MODULE) {
    codemodPackageJson()
  }

  /* Find all `createCollection` call sites and extract their file pattern and options. */
  const collectionConfigurations = getCollectionConfigurations(project)

  if (collectionConfigurations.size > 0) {
    if (!existsSync(PACKAGE_DIRECTORY)) {
      mkdirSync(PACKAGE_DIRECTORY)
    }

    await writeImportMap(collectionConfigurations)
  }

  /* Rewrite all import statements from 'renoun/collections' to '#renoun/collections'. */
  if (WORKSPACE_IS_MODULE) {
    rewriteCollectionImports(project)
  }
}
